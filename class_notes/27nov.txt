index = knnsearch(x, y, 'k', 10)

quais de x (todos os ponto), o nearest neighbour de y (os que se 
segmenta)

perceber a tool do matlab

be careful with mm

pcmerge
pcdownsample
for what?????
compressao? why?
nao se recomenda
usa icp iteractiv closest point -> banal aparentemente

se tiver emparelhado -> procrustes
o problema é emparelhar
pcrigreg funciona em 3d, emparelha, permite rodar caixinha

matriz esparsa, kmean, 3~4 neighbours (ve os 3~4 pontos mais proximos, faz uma media, p todos ate chegar ao ponto central!)
kmean retorna valor di centroide
construir matrizes esparsas entre pontos mais proximos com knn, construir grafos; ignorar pontos a mais de 20 

pode se usar sift de camara para camara
masssssssssssssssssssssss
hmmmmmmmmmmmmmm

R,T cam2 -> cam1, 2 imgs fazer sift, se der match obj em comum, if nt obj so de uma cam

minimos quadrados!?!??!?!?!?!?!?!?!

kmean para 3D????????????yessss

nunca vou ter mais de 10 objectos de certeza absoluta...

kmean + sift = 20

MST vs kmean, kmean faz o clustering minimo, nao é optimo e pode falhar se chegar a um n«minimo local
mst da te sempre o caminho otimo, resolve um problema global
25cm distancia
20cm sao objetos separados, corta ramos, se tiver 2 grafos minimos entao nao é o mesmo objeto
opçao forest da as arvores, ja traz tudo
problema mst nao permite grafo denso, temos que fazer grafo esparso onde vais buscar os 10 mais pertos
procura os 10 vizinhos em profundidade

sift instant t1 para t2
achar RT
com profundidade faço correspondencia
2D, ver em 3D se estao no mesmo sitio

Procrustes vs RANSAC, procrustes pode causar R,T errado pq faz emparelhemento entre os pontos da imagem ate  dif ser minima

SIFT ENTRE IMGS É ESTUPIDO. basta ver de 3D a projeccao das duas

RANSAC: testar c dados reais conhecidos/dados controlados gerados por nos
gerar pc, aplicar RT, gerar pc2.
pegar no ransac, meter outliers em ambas as pc, espetar novos pc e pc2, comparar RT com RT idealizado







